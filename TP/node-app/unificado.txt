
===== Archivo: ./config/config.js =====
Carpeta: ./config
Contenido:
// config/config.js
require('dotenv').config();

module.exports = {
    sessionSecret: process.env.SESSION_SECRET,
    jwtSecret: process.env.JWT_SECRET
};



===== Archivo: ./config/db.js =====
Carpeta: ./config
Contenido:
// config/db.js
const mysql = require('mysql2/promise');
require('dotenv').config();

const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

module.exports = pool;



===== Archivo: ./controllers/adminController.js =====
Carpeta: ./controllers
Contenido:
// controllers/adminController.js

exports.getAdminDashboard = async (req, res) => {
    try {
        // Obtener datos del admin desde req.user o desde la base de datos si es necesario
        const adminData = {
            id: req.user.id,
            email: req.user.email,
            role: req.user.TIPOUSUARIO
            // Agrega más datos si es necesario
        };

        res.render('adminDashboard', { admin: adminData }); // Renderiza la vista adminDashboard.ejs
    } catch (error) {
        console.error('Error al cargar el dashboard de admin:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/authController.js =====
Carpeta: ./controllers
Contenido:
// controllers/authController.js

const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/config');
const { findUserByEmail, verifyPassword } = require('../models/userModel');
const sessionModel = require('../models/sessionModel');

exports.login = async (req, res) => {
    const { email, password } = req.body;

    // Validación básica
    if (!email || !password) {
        return res.status(400).json({ message: 'Por favor, ingresa tu correo y contraseña' });
    }

    try {
        const user = await findUserByEmail(email);
        if (!user) {
            return res.status(400).json({ message: 'Correo o contraseña incorrectos' });
        }

        const isPasswordValid = await verifyPassword(password, user.password);
        if (!isPasswordValid) {
            return res.status(400).json({ message: 'Correo o contraseña incorrectos' });
        }

        // Generar JWT
        const token = jwt.sign(
            { id: user.id, email: user.email, role: user.TIPOUSUARIO },
            jwtSecret,
            { expiresIn: '1h' }
        );

        // Crear una sesión activa
        await sessionModel.createSession(user.id, token);

        // Establecer la cookie HTTP-only
        res.cookie('token', token, {
            httpOnly: true, // No accesible desde JavaScript
            secure: process.env.NODE_ENV === 'production', // Solo HTTPS en producción
            maxAge: 3600000, // 1 hora
            sameSite: 'strict', // Protege contra ataques CSRF
        });

        // Responder con éxito
        res.status(200).json({ message: 'Inicio de sesión exitoso' });
    } catch (err) {
        console.error('Error en login:', err);
        res.status(500).json({ message: 'Error interno del servidor' });
    }
};

exports.logout = async (req, res) => {
    try {
        const token = req.cookies.token;
        if (token) {
            await sessionModel.deleteSession(token);
            res.clearCookie('token');
        }
        res.status(200).json({ message: 'Cierre de sesión exitoso' });
    } catch (err) {
        console.error('Error en logout:', err);
        res.status(500).json({ message: 'Error interno del servidor' });
    }
};



===== Archivo: ./controllers/mesaDeEntradasController - copia.js =====
Carpeta: ./controllers
Contenido:
// controllers/mesaDeEntradasController.js

const Joi = require('joi');
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');

// Definir el esquema de validación con Joi
const mesaDeEntradasSchema = Joi.object({
    motivoConsulta: Joi.string().min(1).max(500).required(),
    explicacionDada: Joi.string().min(1).max(1000).required(),
    // Añade más campos según tus necesidades
});

// Función para renderizar el formulario de Mesa de Entradas
exports.getMesaDeEntradas = async (req, res) => {
    try {
        const [
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        ] = await Promise.all([
            consultasEchasModel.getAllConsultasEchas(),
            expedientesModel.getAllExpedientes(),
            citacionesModel.getAllCitaciones(),
            pedidosModel.getAllPedidos(),
            resolucionesModel.getAllResoluciones()
        ]);

        console.log('consultasEchas:', consultasEchas); // Verificar datos

        res.render('forms/mesaDeEntradas', { 
            csrfToken: req.csrfToken(),
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        });
    } catch (error) {
        console.error('Error al cargar el formulario de Mesa de Entradas:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

// Función para manejar la sumisión del formulario de Mesa de Entradas
exports.handleMesaDeEntradas = async (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { motivoConsulta, explicacionDada } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', { motivoConsulta, explicacionDada });
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

// Rutas API para obtener detalles de registros
exports.getConsultaEchasById = async (req, res) => {
    try {
        const id = req.params.id;
        const consulta = await consultasEchasModel.getConsultaEchaById(id);
        if (!consulta) {
            return res.status(404).json({ message: 'Consulta Echa no encontrada' });
        }
        res.json(consulta);
    } catch (error) {
        console.error('Error en API /api/consultasEchas/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getExpedienteById = async (req, res) => {
    try {
        const id = req.params.id;
        const expediente = await expedientesModel.getExpedienteById(id);
        if (!expediente) {
            return res.status(404).json({ message: 'Expediente no encontrado' });
        }
        res.json(expediente);
    } catch (error) {
        console.error('Error en API /api/expedientes/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getCitacionById = async (req, res) => {
    try {
        const id = req.params.id;
        const citacion = await citacionesModel.getCitacionById(id);
        if (!citacion) {
            return res.status(404).json({ message: 'Citación no encontrada' });
        }
        res.json(citacion);
    } catch (error) {
        console.error('Error en API /api/citaciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getPedidoById = async (req, res) => {
    try {
        const id = req.params.id;
        const pedido = await pedidosModel.getPedidoById(id);
        if (!pedido) {
            return res.status(404).json({ message: 'Pedido no encontrado' });
        }
        res.json(pedido);
    } catch (error) {
        console.error('Error en API /api/pedidos/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getResolucionById = async (req, res) => {
    try {
        const id = req.params.id;
        const resolucion = await resolucionesModel.getResolucionById(id);
        if (!resolucion) {
            return res.status(404).json({ message: 'Resolución no encontrada' });
        }
        res.json(resolucion);
    } catch (error) {
        console.error('Error en API /api/resoluciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/mesaDeEntradasController.js =====
Carpeta: ./controllers
Contenido:
// controllers/mesaDeEntradasController.js

const Joi = require('joi');
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');

// Definir el esquema de validación con Joi
const mesaDeEntradasSchema = Joi.object({
    motivoConsulta: Joi.string().min(1).max(500).required(),
    explicacionDada: Joi.string().min(1).max(1000).required(),
    // Añade más campos según tus necesidades
});

// Función para renderizar el formulario de Mesa de Entradas
// Función para manejar la sumisión del formulario de Mesa de Entradas
exports.handleMesaDeEntradas = async (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { motivoConsulta, explicacionDada } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', { motivoConsulta, explicacionDada });
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

// Rutas API para obtener detalles de registros
exports.getConsultaEchasById = async (req, res) => {
    try {
        const id = req.params.id;
        const consulta = await consultasEchasModel.getConsultaEchaById(id);
        if (!consulta) {
            return res.status(404).json({ message: 'Consulta Echa no encontrada' });
        }
        res.json(consulta);
    } catch (error) {
        console.error('Error en API /api/consultasEchas/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getExpedienteById = async (req, res) => {
    try {
        const id = req.params.id;
        const expediente = await expedientesModel.getExpedienteById(id);
        if (!expediente) {
            return res.status(404).json({ message: 'Expediente no encontrado' });
        }
        res.json(expediente);
    } catch (error) {
        console.error('Error en API /api/expedientes/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getCitacionById = async (req, res) => {
    try {
        const id = req.params.id;
        const citacion = await citacionesModel.getCitacionById(id);
        if (!citacion) {
            return res.status(404).json({ message: 'Citación no encontrada' });
        }
        res.json(citacion);
    } catch (error) {
        console.error('Error en API /api/citaciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getPedidoById = async (req, res) => {
    try {
        const id = req.params.id;
        const pedido = await pedidosModel.getPedidoById(id);
        if (!pedido) {
            return res.status(404).json({ message: 'Pedido no encontrado' });
        }
        res.json(pedido);
    } catch (error) {
        console.error('Error en API /api/pedidos/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getResolucionById = async (req, res) => {
    try {
        const id = req.params.id;
        const resolucion = await resolucionesModel.getResolucionById(id);
        if (!resolucion) {
            return res.status(404).json({ message: 'Resolución no encontrada' });
        }
        res.json(resolucion);
    } catch (error) {
        console.error('Error en API /api/resoluciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/userController.js =====
Carpeta: ./controllers
Contenido:
// controllers/userController.js
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');
const Joi = require('joi');

// Función para renderizar el dashboard del usuario
exports.getUserDashboard = (req, res) => {
    res.render('dashboard', { user: req.user, csrfToken: req.csrfToken() });
};

// Funciones para servir los formularios
exports.getMesaDeEntradas = async (req, res) => {
    try {
        const [consultasEchas, expedientes, citaciones, pedidos, resoluciones] = await Promise.all([
            consultasEchasModel.getAllConsultasEchas(),
            expedientesModel.getAllExpedientes(),
            citacionesModel.getAllCitaciones(),
            pedidosModel.getAllPedidos(),
            resolucionesModel.getAllResoluciones()
        ]);
        res.render('forms/mesaDeEntradas', { 
            csrfToken: req.csrfToken(),
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        });
    } catch (error) {
        console.error('Error al cargar el formulario de Mesa de Entradas:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getGestion = (req, res) => {
    res.render('forms/gestion', { csrfToken: req.csrfToken() });
};

exports.getDireccion = (req, res) => {
    res.render('forms/direccion', { csrfToken: req.csrfToken() });
};

// Validación de los formularios con Joi
const mesaDeEntradasSchema = Joi.object({
    field1: Joi.string().min(1).max(100).required()
});

const gestionSchema = Joi.object({
    field2: Joi.string().min(1).max(100).required()
});

const direccionSchema = Joi.object({
    field3: Joi.string().min(1).max(100).required()
});

// Funciones para manejar las sumisiones de los formularios
exports.handleMesaDeEntradas = (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { field1 } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', field1);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

exports.handleGestion = (req, res) => {
    const { error, value } = gestionSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Gestión:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Gestión');
    }

    const { field2 } = value;
    // Procesa los datos de Gestión de manera segura
    console.log('Gestión recibida y validada:', field2);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

exports.handleDireccion = (req, res) => {
    const { error, value } = direccionSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Dirección:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Dirección');
    }

    const { field3 } = value;
    // Procesa los datos de Dirección de manera segura
    console.log('Dirección recibida y validada:', field3);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};



===== Archivo: ./generateFileList.js =====
Carpeta: .
Contenido:
const fs = require('fs');
const path = require('path');

// Ruta del directorio principal del proyecto
const projectDir = path.join(__dirname);

// Función para recorrer todos los archivos del proyecto
function getFiles(dir, ext, filelist = []) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filepath = path.join(dir, file);
        const stat = fs.statSync(filepath);
        if (stat.isDirectory()) {
            filelist = getFiles(filepath, ext, filelist);
        } else if (path.extname(file) === ext) {
            filelist.push(filepath);
        }
    });
    return filelist;
}

// Obtener todos los archivos .js del proyecto
const jsFiles = getFiles(projectDir, '.js');

// Crear archivo de salida
const outputFilePath = path.join(__dirname, 'lista_archivos_con_texto.txt');
const outputStream = fs.createWriteStream(outputFilePath, { flags: 'w' });

// Escribir el nombre del archivo y su contenido
jsFiles.forEach(file => {
    outputStream.write(`Archivo: ${file}\n`);
    outputStream.write('------------------------------------------\n');
    const content = fs.readFileSync(file, 'utf8');
    outputStream.write(content);
    outputStream.write('\n\n');
});

// Cerrar el archivo de salida
outputStream.end(() => {
    console.log(`Archivo generado: ${outputFilePath}`);
});



===== Archivo: ./middleware/adminLevel.js =====
Carpeta: ./middleware
Contenido:
// middleware/adminLevel.js

module.exports = (requiredRole, requiredLvl) => {
    return (req, res, next) => {
        if (req.user && req.user.role === requiredRole && req.user.lvl === requiredLvl) {
            next();
        } else {
            return res.status(403).json({ message: 'Acceso denegado: No tienes los permisos necesarios' });
        }
    };
};



===== Archivo: ./middleware/auth.js =====
Carpeta: ./middleware
Contenido:
// middleware/auth.js

const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/config');
const sessionModel = require('../models/sessionModel');

module.exports = async (req, res, next) => {
    const token = req.cookies.token;
    if (!token) {
        console.log('No se encontró el token en las cookies.');
        return res.status(401).json({ message: 'Acceso denegado, inicia sesión' });
    }
    try {
        const verified = jwt.verify(token, jwtSecret);
        console.log(`Token verificado para user_id: ${verified.id}`);

        // Verificar si la sesión está activa
        const session = await sessionModel.findActiveSession(verified.id);
        if (!session) {
            console.log('No se encontró ninguna sesión activa para el usuario.');
            return res.status(401).json({ message: 'Sesión inválida o expirada' });
        }

        if (session.token !== token) {
            console.log('El token en la sesión no coincide con el token proporcionado.');
            return res.status(401).json({ message: 'Sesión inválida o expirada' });
        }

        console.log('Sesión verificada exitosamente.');
        req.user = verified;
        next();
    } catch (err) {
        console.error('Error en middleware de autenticación:', err);
        res.status(400).json({ message: 'Token no válido' });
    }
};



===== Archivo: ./middleware/rateLimiter.js =====
Carpeta: ./middleware
Contenido:
// middleware/rateLimiter.js
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // limitar cada IP a 100 solicitudes por ventana
    message: 'Demasiadas solicitudes desde esta IP, por favor intenta más tarde.'
});

module.exports = limiter;



===== Archivo: ./middleware/role.js =====
Carpeta: ./middleware
Contenido:
// middleware/role.js

module.exports = (requiredRoles) => {
    return (req, res, next) => {
        if (!req.user || !requiredRoles.includes(req.user.role)) {
            return res.status(403).json({ message: 'Acceso denegado: No tienes los permisos necesarios' });
        }
        next();
    };
};



===== Archivo: ./middleware/xssProtection.js =====
Carpeta: ./middleware
Contenido:
// middleware/xssProtection.js
const xss = require('xss-clean');

module.exports = xss();



===== Archivo: ./models/citacionesModel.js =====
Carpeta: ./models
Contenido:
// models/citacionesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las citaciones.
     * @returns {Array} - Lista de citaciones.
     */
    getAllCitaciones: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM citaciones');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener citaciones:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una citación por su ID.
     * @param {number} id - ID de la citación.
     * @returns {Object|null} - Citación o null si no se encuentra.
     */
    getCitacionById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM citaciones WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la citación o null
        } catch (error) {
            console.error('Error al obtener citación por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/consultasEchasModel.js =====
Carpeta: ./models
Contenido:
// models/consultasEchasModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las consultas echas.
     * @returns {Array} - Lista de consultas echas.
     */
    getAllConsultasEchas: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM consultas_echas');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener consultas echas:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una consulta echa por su ID.
     * @param {number} id - ID de la consulta.
     * @returns {Object|null} - Consulta echa o null si no se encuentra.
     */
    getConsultaEchaById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM consultas_echas WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la consulta o null
        } catch (error) {
            console.error('Error al obtener consulta echa por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/expedientesModel.js =====
Carpeta: ./models
Contenido:
// models/expedientesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todos los expedientes.
     * @returns {Array} - Lista de expedientes.
     */
    getAllExpedientes: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM expedientes');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener expedientes:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene un expediente por su ID.
     * @param {number} id - ID del expediente.
     * @returns {Object|null} - Expediente o null si no se encuentra.
     */
    getExpedienteById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM expedientes WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve el expediente o null
        } catch (error) {
            console.error('Error al obtener expediente por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/pedidosModel.js =====
Carpeta: ./models
Contenido:
// models/pedidosModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todos los pedidos.
     * @returns {Array} - Lista de pedidos.
     */
    getAllPedidos: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM pedidos');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener pedidos:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene un pedido por su ID.
     * @param {number} id - ID del pedido.
     * @returns {Object|null} - Pedido o null si no se encuentra.
     */
    getPedidoById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM pedidos WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve el pedido o null
        } catch (error) {
            console.error('Error al obtener pedido por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/resolucionesModel.js =====
Carpeta: ./models
Contenido:
// models/resolucionesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las resoluciones.
     * @returns {Array} - Lista de resoluciones.
     */
    getAllResoluciones: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM resoluciones');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener resoluciones:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una resolución por su ID.
     * @param {number} id - ID de la resolución.
     * @returns {Object|null} - Resolución o null si no se encuentra.
     */
    getResolucionById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM resoluciones WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la resolución o null
        } catch (error) {
            console.error('Error al obtener resolución por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/sessionModel.js =====
Carpeta: ./models
Contenido:
// models/sessionModel.js

const db = require('../config/db');

module.exports = {
    /**
     * Busca una sesión activa por el ID del usuario.
     * @param {number} userId - El ID del usuario.
     * @returns {Object|null} - Retorna la sesión si se encuentra, de lo contrario null.
     */
    findActiveSession: async (userId) => {
        try {
            const [rows] = await db.query('SELECT * FROM sessions WHERE user_id = ? AND active = ?', [userId, true]);
            return rows[0] || null;
        } catch (error) {
            console.error('Error al buscar sesión activa:', error);
            throw error;
        }
    },

    /**
     * Crea una nueva sesión en la base de datos.
     * @param {number} userId - El ID del usuario.
     * @param {string} token - El token de la sesión.
     */
    createSession: async (userId, token) => {
        try {
            await db.query('INSERT INTO sessions (user_id, token, active) VALUES (?, ?, ?)', [userId, token, true]);
        } catch (error) {
            console.error('Error al crear sesión:', error);
            throw error;
        }
    },

    /**
     * Elimina una sesión activa por el token.
     * @param {string} token - El token de la sesión.
     */
    deleteSession: async (token) => {
        try {
            await db.query('DELETE FROM sessions WHERE token = ?', [token]);
        } catch (error) {
            console.error('Error al eliminar sesión:', error);
            throw error;
        }
    }
};



===== Archivo: ./models/userModel.js =====
Carpeta: ./models
Contenido:
// models/userModel.js

const db = require('../config/db');
const bcrypt = require('bcrypt');

module.exports = {
    /**
     * Busca un usuario por su correo electrónico.
     * @param {string} email - El correo electrónico del usuario.
     * @returns {Object|null} - Retorna el usuario si se encuentra, de lo contrario null.
     */
    findUserByEmail: async (email) => {
        try {
            const [rows] = await db.query(`
                SELECT 
                    iduser AS id,
                    email, 
                    pass AS password, 
                    TIPOUSUARIO AS TIPOUSUARIO,
                    nameuser,
                    lvl,
                    fondo_imagen,
                    user_fondo,
                    color_preferido,
                    ACTIVO
                FROM users 
                WHERE email = ?
            `, [email]);

            if (rows.length === 0) {
                console.log('No se encontró ningún usuario con el email:', email);
                return null;
            }

            console.log('Usuario encontrado:', rows[0]);
            return rows[0];
        } catch (error) {
            console.error('Error al buscar usuario por email:', error);
            throw error;
        }
    },

    /**
     * Crea un nuevo usuario en la base de datos.
     * @param {string} email - El correo electrónico del usuario.
     * @param {string} password - La contraseña del usuario.
     * @param {string} [role='USER'] - El rol del usuario.
     * @returns {Object} - Resultado de la inserción.
     */
    createUser: async (email, password, role = 'USER') => {
        try {
            const hashedPassword = await bcrypt.hash(password, 10);
            const [result] = await db.query(`
                INSERT INTO users (email, pass, TIPOUSUARIO, nameuser, lvl, ACTIVO) 
                VALUES (?, ?, ?, ?, ?, ?)
            `, [email, hashedPassword, role, 'NombreUsuario', 1, 1]); // Ajusta otros campos según tu esquema
            return result;
        } catch (error) {
            console.error('Error al crear usuario:', error);
            throw error;
        }
    },

    /**
     * Verifica si la contraseña ingresada coincide con la almacenada.
     * @param {string} inputPassword - La contraseña ingresada por el usuario.
     * @param {string} storedPassword - La contraseña hasheada almacenada en la base de datos.
     * @returns {boolean} - Retorna true si las contraseñas coinciden, de lo contrario false.
     */
    verifyPassword: async (inputPassword, storedPassword) => {
        try {
            console.log('Verificando contraseña: inputPassword:', inputPassword, 'storedPassword:', storedPassword);
            if (!inputPassword || !storedPassword) {
                throw new Error('Se requieren ambos argumentos: data y hash.');
            }
            return await bcrypt.compare(inputPassword, storedPassword);
        } catch (error) {
            console.error('Error en verifyPassword:', error);
            throw error;
        }
    }
};



===== Archivo: ./public/js/dashboard - copia.js =====
Carpeta: ./public/js
Contenido:
// public/js/dashboard.js

document.addEventListener('DOMContentLoaded', () => {
    const btnMesaDeEntradas = document.getElementById('btnMesaDeEntradas');
    const btnGestion = document.getElementById('btnGestion');
    const btnDireccion = document.getElementById('btnDireccion');
    const formContainer = document.getElementById('formContainer');
    const dashboardSidebar = document.getElementById('dashboardSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const openSidebarButton = document.getElementById('openSidebarButton');

    // Opcional: Loader
    const formLoader = document.createElement('div');
    formLoader.className = 'form-loader';
    formLoader.innerHTML = '<div class="spinner"></div>';
    formContainer.appendChild(formLoader);

    // Función para cargar formularios
    function loadForm(url) {
        formLoader.style.display = 'block'; // Mostrar el loader
        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'text/html'
            },
            credentials: 'include' // Asegura que las cookies se envían con la solicitud
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error al cargar el formulario');
            }
            return response.text();
        })
        .then(html => {
            formContainer.innerHTML = html;
            hideSidebar(); // Ocultar el sidebar al cargar un formulario
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Ocurrió un error al cargar el formulario.');
        })
        .finally(() => {
            formLoader.style.display = 'none'; // Ocultar el loader
        });
    }

    // Event listeners para los botones
    if (btnMesaDeEntradas) {
        btnMesaDeEntradas.addEventListener('click', () => {
            loadForm('/auth/user/mesaDeEntradas');
            setActiveButton(btnMesaDeEntradas);
        });
    }

    if (btnGestion) {
        btnGestion.addEventListener('click', () => {
            loadForm('/auth/user/gestion');
            setActiveButton(btnGestion);
        });
    }

    if (btnDireccion) {
        btnDireccion.addEventListener('click', () => {
            loadForm('/auth/user/direccion');
            setActiveButton(btnDireccion);
        });
    }

    // Función para resaltar el botón activo
    function setActiveButton(activeBtn) {
        const buttons = document.querySelectorAll('.sidebar-button');
        buttons.forEach(btn => {
            btn.classList.remove('active-button');
        });
        activeBtn.classList.add('active-button');
    }

    // Función para ocultar el sidebar
    function hideSidebar() {
        dashboardSidebar.classList.remove('active');
        sidebarOverlay.classList.remove('active');
    }

    // Función para mostrar el sidebar
    function showSidebar() {
        dashboardSidebar.classList.add('active');
        sidebarOverlay.classList.add('active');
    }

    // Manejar la aparición del sidebar al acercar el mouse al borde izquierdo
    document.addEventListener('mousemove', (e) => {
        if (e.clientX <= 50 && !dashboardSidebar.classList.contains('active')) {
            showSidebar();
        }
    });

    // Manejar el clic en el overlay para ocultar el sidebar
    if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', hideSidebar);
    }

    // Manejar el clic en el botón para abrir el sidebar (en dispositivos móviles)
    if (openSidebarButton) {
        openSidebarButton.addEventListener('click', () => {
            showSidebar();
        });
    }
});

    // Opcional: Cargar un formulario predeterminado al iniciar
    // Por ejemplo, cargar "Mesa de Entradas" por defecto
    // loadForm('/auth/user/mesaDeEntradas');
    // setActiveButton(btnMesaDeEntradas);



===== Archivo: ./public/js/dashboard.js =====
Carpeta: ./public/js
Contenido:
// public/js/dashboard.js

document.addEventListener('DOMContentLoaded', () => {
    const btnMesaDeEntradas = document.getElementById('btnMesaDeEntradas');
    const btnGestion = document.getElementById('btnGestion');
    const btnDireccion = document.getElementById('btnDireccion');
    const formContainer = document.getElementById('formContainer');
    const dashboardSidebar = document.getElementById('dashboardSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const openSidebarButton = document.getElementById('openSidebarButton');

    // Crear el loader
    const formLoader = document.createElement('div');
    formLoader.className = 'form-loader';
    formLoader.innerHTML = '<div class="spinner"></div>';
    formContainer.appendChild(formLoader);

    // Función para cargar formularios
    function loadForm(url) {
        formLoader.style.display = 'block'; // Mostrar el loader
        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'text/html'
            },
            credentials: 'include' // Asegura que las cookies se envían con la solicitud
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error al cargar el formulario');
            }
            return response.text();
        })
        .then(html => {
            formContainer.innerHTML = html;
            // Reagregar el loader después de reemplazar el contenido
            formContainer.appendChild(formLoader);
            hideSidebar(); // Ocultar el sidebar al cargar un formulario
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Ocurrió un error al cargar el formulario.');
        })
        .finally(() => {
            formLoader.style.display = 'none'; // Ocultar el loader
        });
    }

    // Event listeners para los botones
    if (btnMesaDeEntradas) {
        btnMesaDeEntradas.addEventListener('click', () => {
            loadForm('/auth/user/mesaDeEntradas');
            setActiveButton(btnMesaDeEntradas);
        });
    }

    if (btnGestion) {
        btnGestion.addEventListener('click', () => {
            loadForm('/auth/user/gestion');
            setActiveButton(btnGestion);
        });
    }

    if (btnDireccion) {
        btnDireccion.addEventListener('click', () => {
            loadForm('/auth/user/direccion');
            setActiveButton(btnDireccion);
        });
    }

    // Función para resaltar el botón activo
    function setActiveButton(activeBtn) {
        const buttons = document.querySelectorAll('.sidebar-button');
        buttons.forEach(btn => {
            btn.classList.remove('active-button');
        });
        activeBtn.classList.add('active-button');
    }

    // Función para ocultar el sidebar
    function hideSidebar() {
        dashboardSidebar.classList.remove('active');
        sidebarOverlay.classList.remove('active');
    }

    // Función para mostrar el sidebar
    function showSidebar() {
        dashboardSidebar.classList.add('active');
        sidebarOverlay.classList.add('active');
    }

    // Manejar la aparición del sidebar al acercar el mouse al borde izquierdo
    document.addEventListener('mousemove', (e) => {
        if (e.clientX <= 50 && !dashboardSidebar.classList.contains('active')) {
            showSidebar();
        }
    });

    // Manejar el clic en el overlay para ocultar el sidebar
    if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', hideSidebar);
    }

    // Manejar el clic en el botón para abrir el sidebar (en dispositivos móviles)
    if (openSidebarButton) {
        openSidebarButton.addEventListener('click', () => {
            showSidebar();
        });
    }

    // **Elimina o comenta cualquier carga inicial de formularios para evitar mostrar el loader al cargar la página**
    // Por ejemplo, si tienes líneas como estas, asegúrate de que estén comentadas:
    // loadForm('/auth/user/mesaDeEntradas');
    // setActiveButton(btnMesaDeEntradas);
});



===== Archivo: ./public/js/login.js =====
Carpeta: ./public/js
Contenido:
// public/js/login.js

document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');

    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevenir el envío tradicional del formulario

        const formData = new FormData(loginForm);
        const data = Object.fromEntries(formData.entries());

        try {
            const response = await fetch('/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'CSRF-Token': data._csrf // Incluir el token CSRF en las cabeceras
                },
                body: JSON.stringify({
                    email: data.email,
                    password: data.password
                }),
                credentials: 'include' // Asegurar que las cookies se envían con la solicitud
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.message || 'Error al iniciar sesión');
            }

            console.log('Inicio de sesión exitoso:', result.message);
            // Redirigir al dashboard o manejar el éxito según tus necesidades
            window.location.href = '/auth/user/dashboard';
        } catch (error) {
            console.error('Error al iniciar sesión:', error.message);
            alert(`Error al iniciar sesión: ${error.message}`);
        }
    });
});



===== Archivo: ./routes/authRoutes.js =====
Carpeta: ./routes
Contenido:
// routes/authRoutes.js

const express = require('express');
const authController = require('../controllers/authController');
const userController = require('../controllers/userController');
const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/auth');
const roleMiddleware = require('../middleware/role');
const adminLevelMiddleware = require('../middleware/adminLevel'); // Importa el nuevo middleware

const router = express.Router();

// Rutas de autenticación
router.get('/login', (req, res) => {
    res.render('login', { csrfToken: req.csrfToken() });
});

router.post('/login', authController.login);
router.post('/logout', authController.logout);

// Rutas del dashboard de usuario
router.get('/user/dashboard', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getUserDashboard);

// Rutas para servir los formularios de usuario
router.get('/user/mesaDeEntradas', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getMesaDeEntradas);
router.get('/user/gestion', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getGestion);

// Ruta para servir el formulario de Dirección solo para admin lvl 9
router.get('/user/direccion', authMiddleware, adminLevelMiddleware('admin', 9), userController.getDireccion);

// Rutas para manejar las sumisiones de los formularios
router.post('/user/mesaDeEntradas', authMiddleware, roleMiddleware(['USER', 'admin']), userController.handleMesaDeEntradas);
router.post('/user/gestion', authMiddleware, roleMiddleware(['USER', 'admin']), userController.handleGestion);
router.post('/user/direccion', authMiddleware, adminLevelMiddleware('admin', 9), userController.handleDireccion);

// Rutas del dashboard de admin
router.get('/admin/dashboard', authMiddleware, roleMiddleware(['admin']), adminController.getAdminDashboard);

// Log de las funciones de controlador (opcional)
console.log('authController.login:', authController.login);
console.log('authController.logout:', authController.logout);
console.log('userController.getUserDashboard:', userController.getUserDashboard);
console.log('userController.getMesaDeEntradas:', userController.getMesaDeEntradas);
console.log('userController.getGestion:', userController.getGestion);
console.log('userController.getDireccion:', userController.getDireccion);
console.log('userController.handleMesaDeEntradas:', userController.handleMesaDeEntradas);
console.log('userController.handleGestion:', userController.handleGestion);
console.log('userController.handleDireccion:', userController.handleDireccion);
console.log('adminController.getAdminDashboard:', adminController.getAdminDashboard);

module.exports = router;



===== Archivo: ./routes/mesaDeEntradasRoutes.js =====
Carpeta: ./routes
Contenido:
// routes/mesaDeEntradasRoutes.js

const express = require('express');
const mesaDeEntradasController = require('../controllers/mesaDeEntradasController');
const authMiddleware = require('../middleware/auth');
const roleMiddleware = require('../middleware/role');
const userController = require('../controllers/userController');
const router = express.Router();

// Ruta para renderizar el formulario de Mesa de Entradas
router.get(
    '/mesaDeEntradas',
    authMiddleware,
    roleMiddleware(['USER', 'admin']),
    mesaDeEntradasController.getMesaDeEntradas
);

// Ruta para manejar la sumisión del formulario de Mesa de Entradas
router.get(
    '/mesaDeEntradas',
    authMiddleware,
    roleMiddleware(['USER', 'admin']),
    userController.getMesaDeEntradas
);

// Rutas API para obtener detalles de registros
router.get('/api/consultasEchas/:id', authMiddleware, mesaDeEntradasController.getConsultaEchasById);
router.get('/api/expedientes/:id', authMiddleware, mesaDeEntradasController.getExpedienteById);
router.get('/api/citaciones/:id', authMiddleware, mesaDeEntradasController.getCitacionById);
router.get('/api/pedidos/:id', authMiddleware, mesaDeEntradasController.getPedidoById);
router.get('/api/resoluciones/:id', authMiddleware, mesaDeEntradasController.getResolucionById);

module.exports = router;



===== Archivo: ./scripts/createTestuser.js =====
Carpeta: ./scripts
Contenido:
// scripts/createTestUser.js

const { createUser } = require('../models/userModel');

const crearUsuarioPrueba = async () => {
    const email = 'testuser@example.com';
    const password = 'password123'; // Contraseña en texto plano
    const role = 'USER'; // o 'admin'

    try {
        await createUser(email, password, role);
        console.log('Usuario de prueba creado exitosamente.');
    } catch (error) {
        console.error('Error al crear usuario de prueba:', error);
    }
};

crearUsuarioPrueba();



===== Archivo: ./server.js =====
Carpeta: .
Contenido:
// server.js

const express = require('express');
const helmet = require('helmet');
const path = require('path');
const session = require('express-session');
const rateLimiter = require('./middleware/rateLimiter');
const xssProtection = require('./middleware/xssProtection');
const authRoutes = require('./routes/authRoutes');
const mesaDeEntradasRoutes = require('./routes/mesaDeEntradasRoutes'); // Importar el nuevo archivo de rutas
const { sessionSecret } = require('./config/config');
const morgan = require('morgan');
const fs = require('fs');
const { createStream } = require('rotating-file-stream'); // Para rotación de logs
const cookieParser = require('cookie-parser');
const csrf = require('csurf'); // Importar csurf
require('dotenv').config();

const app = express();

// Middlewares de seguridad con Helmet
app.use(
    helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'"],
                styleSrc: ["'self'", 'https:'],
                imgSrc: ["'self'", 'data:'],
                connectSrc: ["'self'"],
                fontSrc: ["'self'", 'https:', 'data:'],
                objectSrc: ["'none'"],
                upgradeInsecureRequests: [],
            },
        },
    })
);

// Middleware para parsear cuerpos de solicitudes
app.use(express.urlencoded({ extended: false }));
app.use(express.json());

// Middleware para parsear cookies
app.use(cookieParser());

// Limitar solicitudes
app.use(rateLimiter);

// Protección contra ataques XSS
app.use(xssProtection);

// Logger para registrar solicitudes en logs
const logDirectory = path.join(__dirname, 'logs');

// Asegurarse de que el directorio de logs existe
fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);

const accessLogStream = createStream('access.log', {
    interval: '1d', // Rotar diariamente
    path: logDirectory
});

app.use(morgan('combined', { stream: accessLogStream }));

// Gestión de sesión
app.use(session({
    secret: sessionSecret,
    resave: false,
    saveUninitialized: true,
    cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict'
    }
}));

// Configurar csurf middleware después de cookieParser y session
app.use(csrf());

// Middleware para pasar el token CSRF a todas las vistas
app.use((req, res, next) => {
    res.locals.csrfToken = req.csrfToken();
    next();
});

// Motor de plantillas EJS
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware para servir archivos estáticos - DEBE ESTAR ANTES DE LAS RUTas
app.use(express.static(path.join(__dirname, 'public')));

// Rutas
app.use('/auth', authRoutes);
app.use('/auth/user', mesaDeEntradasRoutes); // Montar las rutas de Mesa de Entradas bajo /auth/user
// Ruta raíz redirige a login
app.get('/', (req, res) => {
    res.redirect('/auth/login');
});

// Manejo de errores global
app.use((err, req, res, next) => {
    if (err.code === 'EBADCSRFTOKEN') {
        // Manejar el error de CSRF
        res.status(403).json({ message: 'Formulario inválido' });
    } else {
        console.error(err.stack);
        res.status(500).json({ message: 'Ocurrió un error en el servidor' });
    }
});

// Iniciar servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Servidor corriendo en el puerto ${PORT}`);
});



===== Archivo: ./unificado.txt =====
Carpeta: .
Contenido:

===== Archivo: ./config/config.js =====
Carpeta: ./config
Contenido:
// config/config.js
require('dotenv').config();

module.exports = {
    sessionSecret: process.env.SESSION_SECRET,
    jwtSecret: process.env.JWT_SECRET
};



===== Archivo: ./config/db.js =====
Carpeta: ./config
Contenido:
// config/db.js
const mysql = require('mysql2/promise');
require('dotenv').config();

const pool = mysql.createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

module.exports = pool;



===== Archivo: ./controllers/adminController.js =====
Carpeta: ./controllers
Contenido:
// controllers/adminController.js

exports.getAdminDashboard = async (req, res) => {
    try {
        // Obtener datos del admin desde req.user o desde la base de datos si es necesario
        const adminData = {
            id: req.user.id,
            email: req.user.email,
            role: req.user.TIPOUSUARIO
            // Agrega más datos si es necesario
        };

        res.render('adminDashboard', { admin: adminData }); // Renderiza la vista adminDashboard.ejs
    } catch (error) {
        console.error('Error al cargar el dashboard de admin:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/authController.js =====
Carpeta: ./controllers
Contenido:
// controllers/authController.js

const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/config');
const { findUserByEmail, verifyPassword } = require('../models/userModel');
const sessionModel = require('../models/sessionModel');

exports.login = async (req, res) => {
    const { email, password } = req.body;

    // Validación básica
    if (!email || !password) {
        return res.status(400).json({ message: 'Por favor, ingresa tu correo y contraseña' });
    }

    try {
        const user = await findUserByEmail(email);
        if (!user) {
            return res.status(400).json({ message: 'Correo o contraseña incorrectos' });
        }

        const isPasswordValid = await verifyPassword(password, user.password);
        if (!isPasswordValid) {
            return res.status(400).json({ message: 'Correo o contraseña incorrectos' });
        }

        // Generar JWT
        const token = jwt.sign(
            { id: user.id, email: user.email, role: user.TIPOUSUARIO },
            jwtSecret,
            { expiresIn: '1h' }
        );

        // Crear una sesión activa
        await sessionModel.createSession(user.id, token);

        // Establecer la cookie HTTP-only
        res.cookie('token', token, {
            httpOnly: true, // No accesible desde JavaScript
            secure: process.env.NODE_ENV === 'production', // Solo HTTPS en producción
            maxAge: 3600000, // 1 hora
            sameSite: 'strict', // Protege contra ataques CSRF
        });

        // Responder con éxito
        res.status(200).json({ message: 'Inicio de sesión exitoso' });
    } catch (err) {
        console.error('Error en login:', err);
        res.status(500).json({ message: 'Error interno del servidor' });
    }
};

exports.logout = async (req, res) => {
    try {
        const token = req.cookies.token;
        if (token) {
            await sessionModel.deleteSession(token);
            res.clearCookie('token');
        }
        res.status(200).json({ message: 'Cierre de sesión exitoso' });
    } catch (err) {
        console.error('Error en logout:', err);
        res.status(500).json({ message: 'Error interno del servidor' });
    }
};



===== Archivo: ./controllers/mesaDeEntradasController - copia.js =====
Carpeta: ./controllers
Contenido:
// controllers/mesaDeEntradasController.js

const Joi = require('joi');
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');

// Definir el esquema de validación con Joi
const mesaDeEntradasSchema = Joi.object({
    motivoConsulta: Joi.string().min(1).max(500).required(),
    explicacionDada: Joi.string().min(1).max(1000).required(),
    // Añade más campos según tus necesidades
});

// Función para renderizar el formulario de Mesa de Entradas
exports.getMesaDeEntradas = async (req, res) => {
    try {
        const [
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        ] = await Promise.all([
            consultasEchasModel.getAllConsultasEchas(),
            expedientesModel.getAllExpedientes(),
            citacionesModel.getAllCitaciones(),
            pedidosModel.getAllPedidos(),
            resolucionesModel.getAllResoluciones()
        ]);

        console.log('consultasEchas:', consultasEchas); // Verificar datos

        res.render('forms/mesaDeEntradas', { 
            csrfToken: req.csrfToken(),
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        });
    } catch (error) {
        console.error('Error al cargar el formulario de Mesa de Entradas:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

// Función para manejar la sumisión del formulario de Mesa de Entradas
exports.handleMesaDeEntradas = async (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { motivoConsulta, explicacionDada } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', { motivoConsulta, explicacionDada });
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

// Rutas API para obtener detalles de registros
exports.getConsultaEchasById = async (req, res) => {
    try {
        const id = req.params.id;
        const consulta = await consultasEchasModel.getConsultaEchaById(id);
        if (!consulta) {
            return res.status(404).json({ message: 'Consulta Echa no encontrada' });
        }
        res.json(consulta);
    } catch (error) {
        console.error('Error en API /api/consultasEchas/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getExpedienteById = async (req, res) => {
    try {
        const id = req.params.id;
        const expediente = await expedientesModel.getExpedienteById(id);
        if (!expediente) {
            return res.status(404).json({ message: 'Expediente no encontrado' });
        }
        res.json(expediente);
    } catch (error) {
        console.error('Error en API /api/expedientes/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getCitacionById = async (req, res) => {
    try {
        const id = req.params.id;
        const citacion = await citacionesModel.getCitacionById(id);
        if (!citacion) {
            return res.status(404).json({ message: 'Citación no encontrada' });
        }
        res.json(citacion);
    } catch (error) {
        console.error('Error en API /api/citaciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getPedidoById = async (req, res) => {
    try {
        const id = req.params.id;
        const pedido = await pedidosModel.getPedidoById(id);
        if (!pedido) {
            return res.status(404).json({ message: 'Pedido no encontrado' });
        }
        res.json(pedido);
    } catch (error) {
        console.error('Error en API /api/pedidos/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getResolucionById = async (req, res) => {
    try {
        const id = req.params.id;
        const resolucion = await resolucionesModel.getResolucionById(id);
        if (!resolucion) {
            return res.status(404).json({ message: 'Resolución no encontrada' });
        }
        res.json(resolucion);
    } catch (error) {
        console.error('Error en API /api/resoluciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/mesaDeEntradasController.js =====
Carpeta: ./controllers
Contenido:
// controllers/mesaDeEntradasController.js

const Joi = require('joi');
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');

// Definir el esquema de validación con Joi
const mesaDeEntradasSchema = Joi.object({
    motivoConsulta: Joi.string().min(1).max(500).required(),
    explicacionDada: Joi.string().min(1).max(1000).required(),
    // Añade más campos según tus necesidades
});

// Función para renderizar el formulario de Mesa de Entradas
// Función para manejar la sumisión del formulario de Mesa de Entradas
exports.handleMesaDeEntradas = async (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { motivoConsulta, explicacionDada } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', { motivoConsulta, explicacionDada });
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

// Rutas API para obtener detalles de registros
exports.getConsultaEchasById = async (req, res) => {
    try {
        const id = req.params.id;
        const consulta = await consultasEchasModel.getConsultaEchaById(id);
        if (!consulta) {
            return res.status(404).json({ message: 'Consulta Echa no encontrada' });
        }
        res.json(consulta);
    } catch (error) {
        console.error('Error en API /api/consultasEchas/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getExpedienteById = async (req, res) => {
    try {
        const id = req.params.id;
        const expediente = await expedientesModel.getExpedienteById(id);
        if (!expediente) {
            return res.status(404).json({ message: 'Expediente no encontrado' });
        }
        res.json(expediente);
    } catch (error) {
        console.error('Error en API /api/expedientes/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getCitacionById = async (req, res) => {
    try {
        const id = req.params.id;
        const citacion = await citacionesModel.getCitacionById(id);
        if (!citacion) {
            return res.status(404).json({ message: 'Citación no encontrada' });
        }
        res.json(citacion);
    } catch (error) {
        console.error('Error en API /api/citaciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getPedidoById = async (req, res) => {
    try {
        const id = req.params.id;
        const pedido = await pedidosModel.getPedidoById(id);
        if (!pedido) {
            return res.status(404).json({ message: 'Pedido no encontrado' });
        }
        res.json(pedido);
    } catch (error) {
        console.error('Error en API /api/pedidos/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getResolucionById = async (req, res) => {
    try {
        const id = req.params.id;
        const resolucion = await resolucionesModel.getResolucionById(id);
        if (!resolucion) {
            return res.status(404).json({ message: 'Resolución no encontrada' });
        }
        res.json(resolucion);
    } catch (error) {
        console.error('Error en API /api/resoluciones/:id:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};



===== Archivo: ./controllers/userController.js =====
Carpeta: ./controllers
Contenido:
// controllers/userController.js
const consultasEchasModel = require('../models/consultasEchasModel');
const expedientesModel = require('../models/expedientesModel');
const citacionesModel = require('../models/citacionesModel');
const pedidosModel = require('../models/pedidosModel');
const resolucionesModel = require('../models/resolucionesModel');
const Joi = require('joi');

// Función para renderizar el dashboard del usuario
exports.getUserDashboard = (req, res) => {
    res.render('dashboard', { user: req.user, csrfToken: req.csrfToken() });
};

// Funciones para servir los formularios
exports.getMesaDeEntradas = async (req, res) => {
    try {
        const [consultasEchas, expedientes, citaciones, pedidos, resoluciones] = await Promise.all([
            consultasEchasModel.getAllConsultasEchas(),
            expedientesModel.getAllExpedientes(),
            citacionesModel.getAllCitaciones(),
            pedidosModel.getAllPedidos(),
            resolucionesModel.getAllResoluciones()
        ]);
        res.render('forms/mesaDeEntradas', { 
            csrfToken: req.csrfToken(),
            consultasEchas,
            expedientes,
            citaciones,
            pedidos,
            resoluciones
        });
    } catch (error) {
        console.error('Error al cargar el formulario de Mesa de Entradas:', error);
        res.status(500).json({ message: 'Error en el servidor' });
    }
};

exports.getGestion = (req, res) => {
    res.render('forms/gestion', { csrfToken: req.csrfToken() });
};

exports.getDireccion = (req, res) => {
    res.render('forms/direccion', { csrfToken: req.csrfToken() });
};

// Validación de los formularios con Joi
const mesaDeEntradasSchema = Joi.object({
    field1: Joi.string().min(1).max(100).required()
});

const gestionSchema = Joi.object({
    field2: Joi.string().min(1).max(100).required()
});

const direccionSchema = Joi.object({
    field3: Joi.string().min(1).max(100).required()
});

// Funciones para manejar las sumisiones de los formularios
exports.handleMesaDeEntradas = (req, res) => {
    const { error, value } = mesaDeEntradasSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Mesa de Entradas:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Mesa de Entradas');
    }

    const { field1 } = value;
    // Procesa los datos de Mesa de Entradas de manera segura
    console.log('Mesa de Entradas recibida y validada:', field1);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

exports.handleGestion = (req, res) => {
    const { error, value } = gestionSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Gestión:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Gestión');
    }

    const { field2 } = value;
    // Procesa los datos de Gestión de manera segura
    console.log('Gestión recibida y validada:', field2);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};

exports.handleDireccion = (req, res) => {
    const { error, value } = direccionSchema.validate(req.body);
    if (error) {
        console.log('Validación fallida en Dirección:', error.details[0].message);
        return res.status(400).send('Datos inválidos en Dirección');
    }

    const { field3 } = value;
    // Procesa los datos de Dirección de manera segura
    console.log('Dirección recibida y validada:', field3);
    // Realiza operaciones necesarias (base de datos, lógica de negocio, etc.)
    res.redirect('/auth/user/dashboard');
};



===== Archivo: ./generateFileList.js =====
Carpeta: .
Contenido:
const fs = require('fs');
const path = require('path');

// Ruta del directorio principal del proyecto
const projectDir = path.join(__dirname);

// Función para recorrer todos los archivos del proyecto
function getFiles(dir, ext, filelist = []) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filepath = path.join(dir, file);
        const stat = fs.statSync(filepath);
        if (stat.isDirectory()) {
            filelist = getFiles(filepath, ext, filelist);
        } else if (path.extname(file) === ext) {
            filelist.push(filepath);
        }
    });
    return filelist;
}

// Obtener todos los archivos .js del proyecto
const jsFiles = getFiles(projectDir, '.js');

// Crear archivo de salida
const outputFilePath = path.join(__dirname, 'lista_archivos_con_texto.txt');
const outputStream = fs.createWriteStream(outputFilePath, { flags: 'w' });

// Escribir el nombre del archivo y su contenido
jsFiles.forEach(file => {
    outputStream.write(`Archivo: ${file}\n`);
    outputStream.write('------------------------------------------\n');
    const content = fs.readFileSync(file, 'utf8');
    outputStream.write(content);
    outputStream.write('\n\n');
});

// Cerrar el archivo de salida
outputStream.end(() => {
    console.log(`Archivo generado: ${outputFilePath}`);
});



===== Archivo: ./middleware/adminLevel.js =====
Carpeta: ./middleware
Contenido:
// middleware/adminLevel.js

module.exports = (requiredRole, requiredLvl) => {
    return (req, res, next) => {
        if (req.user && req.user.role === requiredRole && req.user.lvl === requiredLvl) {
            next();
        } else {
            return res.status(403).json({ message: 'Acceso denegado: No tienes los permisos necesarios' });
        }
    };
};



===== Archivo: ./middleware/auth.js =====
Carpeta: ./middleware
Contenido:
// middleware/auth.js

const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/config');
const sessionModel = require('../models/sessionModel');

module.exports = async (req, res, next) => {
    const token = req.cookies.token;
    if (!token) {
        console.log('No se encontró el token en las cookies.');
        return res.status(401).json({ message: 'Acceso denegado, inicia sesión' });
    }
    try {
        const verified = jwt.verify(token, jwtSecret);
        console.log(`Token verificado para user_id: ${verified.id}`);

        // Verificar si la sesión está activa
        const session = await sessionModel.findActiveSession(verified.id);
        if (!session) {
            console.log('No se encontró ninguna sesión activa para el usuario.');
            return res.status(401).json({ message: 'Sesión inválida o expirada' });
        }

        if (session.token !== token) {
            console.log('El token en la sesión no coincide con el token proporcionado.');
            return res.status(401).json({ message: 'Sesión inválida o expirada' });
        }

        console.log('Sesión verificada exitosamente.');
        req.user = verified;
        next();
    } catch (err) {
        console.error('Error en middleware de autenticación:', err);
        res.status(400).json({ message: 'Token no válido' });
    }
};



===== Archivo: ./middleware/rateLimiter.js =====
Carpeta: ./middleware
Contenido:
// middleware/rateLimiter.js
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // limitar cada IP a 100 solicitudes por ventana
    message: 'Demasiadas solicitudes desde esta IP, por favor intenta más tarde.'
});

module.exports = limiter;



===== Archivo: ./middleware/role.js =====
Carpeta: ./middleware
Contenido:
// middleware/role.js

module.exports = (requiredRoles) => {
    return (req, res, next) => {
        if (!req.user || !requiredRoles.includes(req.user.role)) {
            return res.status(403).json({ message: 'Acceso denegado: No tienes los permisos necesarios' });
        }
        next();
    };
};



===== Archivo: ./middleware/xssProtection.js =====
Carpeta: ./middleware
Contenido:
// middleware/xssProtection.js
const xss = require('xss-clean');

module.exports = xss();



===== Archivo: ./models/citacionesModel.js =====
Carpeta: ./models
Contenido:
// models/citacionesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las citaciones.
     * @returns {Array} - Lista de citaciones.
     */
    getAllCitaciones: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM citaciones');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener citaciones:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una citación por su ID.
     * @param {number} id - ID de la citación.
     * @returns {Object|null} - Citación o null si no se encuentra.
     */
    getCitacionById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM citaciones WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la citación o null
        } catch (error) {
            console.error('Error al obtener citación por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/consultasEchasModel.js =====
Carpeta: ./models
Contenido:
// models/consultasEchasModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las consultas echas.
     * @returns {Array} - Lista de consultas echas.
     */
    getAllConsultasEchas: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM consultas_echas');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener consultas echas:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una consulta echa por su ID.
     * @param {number} id - ID de la consulta.
     * @returns {Object|null} - Consulta echa o null si no se encuentra.
     */
    getConsultaEchaById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM consultas_echas WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la consulta o null
        } catch (error) {
            console.error('Error al obtener consulta echa por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/expedientesModel.js =====
Carpeta: ./models
Contenido:
// models/expedientesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todos los expedientes.
     * @returns {Array} - Lista de expedientes.
     */
    getAllExpedientes: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM expedientes');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener expedientes:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene un expediente por su ID.
     * @param {number} id - ID del expediente.
     * @returns {Object|null} - Expediente o null si no se encuentra.
     */
    getExpedienteById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM expedientes WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve el expediente o null
        } catch (error) {
            console.error('Error al obtener expediente por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/pedidosModel.js =====
Carpeta: ./models
Contenido:
// models/pedidosModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todos los pedidos.
     * @returns {Array} - Lista de pedidos.
     */
    getAllPedidos: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM pedidos');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener pedidos:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene un pedido por su ID.
     * @param {number} id - ID del pedido.
     * @returns {Object|null} - Pedido o null si no se encuentra.
     */
    getPedidoById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM pedidos WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve el pedido o null
        } catch (error) {
            console.error('Error al obtener pedido por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/resolucionesModel.js =====
Carpeta: ./models
Contenido:
// models/resolucionesModel.js
const db = require('../config/db');

module.exports = {
    /**
     * Obtiene todas las resoluciones.
     * @returns {Array} - Lista de resoluciones.
     */
    getAllResoluciones: async () => {
        try {
            const [rows] = await db.query('SELECT * FROM resoluciones');
            return rows; // Devuelve todas las filas
        } catch (error) {
            console.error('Error al obtener resoluciones:', error);
            throw error; // Lanza el error para manejo posterior
        }
    },

    /**
     * Obtiene una resolución por su ID.
     * @param {number} id - ID de la resolución.
     * @returns {Object|null} - Resolución o null si no se encuentra.
     */
    getResolucionById: async (id) => {
        try {
            const [rows] = await db.query('SELECT * FROM resoluciones WHERE id = ?', [id]); // Consulta segura
            return rows[0] || null; // Devuelve la resolución o null
        } catch (error) {
            console.error('Error al obtener resolución por ID:', error);
            throw error; // Lanza el error para manejo posterior
        }
    }
};



===== Archivo: ./models/sessionModel.js =====
Carpeta: ./models
Contenido:
// models/sessionModel.js

const db = require('../config/db');

module.exports = {
    /**
     * Busca una sesión activa por el ID del usuario.
     * @param {number} userId - El ID del usuario.
     * @returns {Object|null} - Retorna la sesión si se encuentra, de lo contrario null.
     */
    findActiveSession: async (userId) => {
        try {
            const [rows] = await db.query('SELECT * FROM sessions WHERE user_id = ? AND active = ?', [userId, true]);
            return rows[0] || null;
        } catch (error) {
            console.error('Error al buscar sesión activa:', error);
            throw error;
        }
    },

    /**
     * Crea una nueva sesión en la base de datos.
     * @param {number} userId - El ID del usuario.
     * @param {string} token - El token de la sesión.
     */
    createSession: async (userId, token) => {
        try {
            await db.query('INSERT INTO sessions (user_id, token, active) VALUES (?, ?, ?)', [userId, token, true]);
        } catch (error) {
            console.error('Error al crear sesión:', error);
            throw error;
        }
    },

    /**
     * Elimina una sesión activa por el token.
     * @param {string} token - El token de la sesión.
     */
    deleteSession: async (token) => {
        try {
            await db.query('DELETE FROM sessions WHERE token = ?', [token]);
        } catch (error) {
            console.error('Error al eliminar sesión:', error);
            throw error;
        }
    }
};



===== Archivo: ./models/userModel.js =====
Carpeta: ./models
Contenido:
// models/userModel.js

const db = require('../config/db');
const bcrypt = require('bcrypt');

module.exports = {
    /**
     * Busca un usuario por su correo electrónico.
     * @param {string} email - El correo electrónico del usuario.
     * @returns {Object|null} - Retorna el usuario si se encuentra, de lo contrario null.
     */
    findUserByEmail: async (email) => {
        try {
            const [rows] = await db.query(`
                SELECT 
                    iduser AS id,
                    email, 
                    pass AS password, 
                    TIPOUSUARIO AS TIPOUSUARIO,
                    nameuser,
                    lvl,
                    fondo_imagen,
                    user_fondo,
                    color_preferido,
                    ACTIVO
                FROM users 
                WHERE email = ?
            `, [email]);

            if (rows.length === 0) {
                console.log('No se encontró ningún usuario con el email:', email);
                return null;
            }

            console.log('Usuario encontrado:', rows[0]);
            return rows[0];
        } catch (error) {
            console.error('Error al buscar usuario por email:', error);
            throw error;
        }
    },

    /**
     * Crea un nuevo usuario en la base de datos.
     * @param {string} email - El correo electrónico del usuario.
     * @param {string} password - La contraseña del usuario.
     * @param {string} [role='USER'] - El rol del usuario.
     * @returns {Object} - Resultado de la inserción.
     */
    createUser: async (email, password, role = 'USER') => {
        try {
            const hashedPassword = await bcrypt.hash(password, 10);
            const [result] = await db.query(`
                INSERT INTO users (email, pass, TIPOUSUARIO, nameuser, lvl, ACTIVO) 
                VALUES (?, ?, ?, ?, ?, ?)
            `, [email, hashedPassword, role, 'NombreUsuario', 1, 1]); // Ajusta otros campos según tu esquema
            return result;
        } catch (error) {
            console.error('Error al crear usuario:', error);
            throw error;
        }
    },

    /**
     * Verifica si la contraseña ingresada coincide con la almacenada.
     * @param {string} inputPassword - La contraseña ingresada por el usuario.
     * @param {string} storedPassword - La contraseña hasheada almacenada en la base de datos.
     * @returns {boolean} - Retorna true si las contraseñas coinciden, de lo contrario false.
     */
    verifyPassword: async (inputPassword, storedPassword) => {
        try {
            console.log('Verificando contraseña: inputPassword:', inputPassword, 'storedPassword:', storedPassword);
            if (!inputPassword || !storedPassword) {
                throw new Error('Se requieren ambos argumentos: data y hash.');
            }
            return await bcrypt.compare(inputPassword, storedPassword);
        } catch (error) {
            console.error('Error en verifyPassword:', error);
            throw error;
        }
    }
};



===== Archivo: ./public/js/dashboard - copia.js =====
Carpeta: ./public/js
Contenido:
// public/js/dashboard.js

document.addEventListener('DOMContentLoaded', () => {
    const btnMesaDeEntradas = document.getElementById('btnMesaDeEntradas');
    const btnGestion = document.getElementById('btnGestion');
    const btnDireccion = document.getElementById('btnDireccion');
    const formContainer = document.getElementById('formContainer');
    const dashboardSidebar = document.getElementById('dashboardSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const openSidebarButton = document.getElementById('openSidebarButton');

    // Opcional: Loader
    const formLoader = document.createElement('div');
    formLoader.className = 'form-loader';
    formLoader.innerHTML = '<div class="spinner"></div>';
    formContainer.appendChild(formLoader);

    // Función para cargar formularios
    function loadForm(url) {
        formLoader.style.display = 'block'; // Mostrar el loader
        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'text/html'
            },
            credentials: 'include' // Asegura que las cookies se envían con la solicitud
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error al cargar el formulario');
            }
            return response.text();
        })
        .then(html => {
            formContainer.innerHTML = html;
            hideSidebar(); // Ocultar el sidebar al cargar un formulario
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Ocurrió un error al cargar el formulario.');
        })
        .finally(() => {
            formLoader.style.display = 'none'; // Ocultar el loader
        });
    }

    // Event listeners para los botones
    if (btnMesaDeEntradas) {
        btnMesaDeEntradas.addEventListener('click', () => {
            loadForm('/auth/user/mesaDeEntradas');
            setActiveButton(btnMesaDeEntradas);
        });
    }

    if (btnGestion) {
        btnGestion.addEventListener('click', () => {
            loadForm('/auth/user/gestion');
            setActiveButton(btnGestion);
        });
    }

    if (btnDireccion) {
        btnDireccion.addEventListener('click', () => {
            loadForm('/auth/user/direccion');
            setActiveButton(btnDireccion);
        });
    }

    // Función para resaltar el botón activo
    function setActiveButton(activeBtn) {
        const buttons = document.querySelectorAll('.sidebar-button');
        buttons.forEach(btn => {
            btn.classList.remove('active-button');
        });
        activeBtn.classList.add('active-button');
    }

    // Función para ocultar el sidebar
    function hideSidebar() {
        dashboardSidebar.classList.remove('active');
        sidebarOverlay.classList.remove('active');
    }

    // Función para mostrar el sidebar
    function showSidebar() {
        dashboardSidebar.classList.add('active');
        sidebarOverlay.classList.add('active');
    }

    // Manejar la aparición del sidebar al acercar el mouse al borde izquierdo
    document.addEventListener('mousemove', (e) => {
        if (e.clientX <= 50 && !dashboardSidebar.classList.contains('active')) {
            showSidebar();
        }
    });

    // Manejar el clic en el overlay para ocultar el sidebar
    if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', hideSidebar);
    }

    // Manejar el clic en el botón para abrir el sidebar (en dispositivos móviles)
    if (openSidebarButton) {
        openSidebarButton.addEventListener('click', () => {
            showSidebar();
        });
    }
});

    // Opcional: Cargar un formulario predeterminado al iniciar
    // Por ejemplo, cargar "Mesa de Entradas" por defecto
    // loadForm('/auth/user/mesaDeEntradas');
    // setActiveButton(btnMesaDeEntradas);



===== Archivo: ./public/js/dashboard.js =====
Carpeta: ./public/js
Contenido:
// public/js/dashboard.js

document.addEventListener('DOMContentLoaded', () => {
    const btnMesaDeEntradas = document.getElementById('btnMesaDeEntradas');
    const btnGestion = document.getElementById('btnGestion');
    const btnDireccion = document.getElementById('btnDireccion');
    const formContainer = document.getElementById('formContainer');
    const dashboardSidebar = document.getElementById('dashboardSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const openSidebarButton = document.getElementById('openSidebarButton');

    // Crear el loader
    const formLoader = document.createElement('div');
    formLoader.className = 'form-loader';
    formLoader.innerHTML = '<div class="spinner"></div>';
    formContainer.appendChild(formLoader);

    // Función para cargar formularios
    function loadForm(url) {
        formLoader.style.display = 'block'; // Mostrar el loader
        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'text/html'
            },
            credentials: 'include' // Asegura que las cookies se envían con la solicitud
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error al cargar el formulario');
            }
            return response.text();
        })
        .then(html => {
            formContainer.innerHTML = html;
            // Reagregar el loader después de reemplazar el contenido
            formContainer.appendChild(formLoader);
            hideSidebar(); // Ocultar el sidebar al cargar un formulario
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Ocurrió un error al cargar el formulario.');
        })
        .finally(() => {
            formLoader.style.display = 'none'; // Ocultar el loader
        });
    }

    // Event listeners para los botones
    if (btnMesaDeEntradas) {
        btnMesaDeEntradas.addEventListener('click', () => {
            loadForm('/auth/user/mesaDeEntradas');
            setActiveButton(btnMesaDeEntradas);
        });
    }

    if (btnGestion) {
        btnGestion.addEventListener('click', () => {
            loadForm('/auth/user/gestion');
            setActiveButton(btnGestion);
        });
    }

    if (btnDireccion) {
        btnDireccion.addEventListener('click', () => {
            loadForm('/auth/user/direccion');
            setActiveButton(btnDireccion);
        });
    }

    // Función para resaltar el botón activo
    function setActiveButton(activeBtn) {
        const buttons = document.querySelectorAll('.sidebar-button');
        buttons.forEach(btn => {
            btn.classList.remove('active-button');
        });
        activeBtn.classList.add('active-button');
    }

    // Función para ocultar el sidebar
    function hideSidebar() {
        dashboardSidebar.classList.remove('active');
        sidebarOverlay.classList.remove('active');
    }

    // Función para mostrar el sidebar
    function showSidebar() {
        dashboardSidebar.classList.add('active');
        sidebarOverlay.classList.add('active');
    }

    // Manejar la aparición del sidebar al acercar el mouse al borde izquierdo
    document.addEventListener('mousemove', (e) => {
        if (e.clientX <= 50 && !dashboardSidebar.classList.contains('active')) {
            showSidebar();
        }
    });

    // Manejar el clic en el overlay para ocultar el sidebar
    if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', hideSidebar);
    }

    // Manejar el clic en el botón para abrir el sidebar (en dispositivos móviles)
    if (openSidebarButton) {
        openSidebarButton.addEventListener('click', () => {
            showSidebar();
        });
    }

    // **Elimina o comenta cualquier carga inicial de formularios para evitar mostrar el loader al cargar la página**
    // Por ejemplo, si tienes líneas como estas, asegúrate de que estén comentadas:
    // loadForm('/auth/user/mesaDeEntradas');
    // setActiveButton(btnMesaDeEntradas);
});



===== Archivo: ./public/js/login.js =====
Carpeta: ./public/js
Contenido:
// public/js/login.js

document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');

    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevenir el envío tradicional del formulario

        const formData = new FormData(loginForm);
        const data = Object.fromEntries(formData.entries());

        try {
            const response = await fetch('/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'CSRF-Token': data._csrf // Incluir el token CSRF en las cabeceras
                },
                body: JSON.stringify({
                    email: data.email,
                    password: data.password
                }),
                credentials: 'include' // Asegurar que las cookies se envían con la solicitud
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.message || 'Error al iniciar sesión');
            }

            console.log('Inicio de sesión exitoso:', result.message);
            // Redirigir al dashboard o manejar el éxito según tus necesidades
            window.location.href = '/auth/user/dashboard';
        } catch (error) {
            console.error('Error al iniciar sesión:', error.message);
            alert(`Error al iniciar sesión: ${error.message}`);
        }
    });
});



===== Archivo: ./routes/authRoutes.js =====
Carpeta: ./routes
Contenido:
// routes/authRoutes.js

const express = require('express');
const authController = require('../controllers/authController');
const userController = require('../controllers/userController');
const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/auth');
const roleMiddleware = require('../middleware/role');
const adminLevelMiddleware = require('../middleware/adminLevel'); // Importa el nuevo middleware

const router = express.Router();

// Rutas de autenticación
router.get('/login', (req, res) => {
    res.render('login', { csrfToken: req.csrfToken() });
});

router.post('/login', authController.login);
router.post('/logout', authController.logout);

// Rutas del dashboard de usuario
router.get('/user/dashboard', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getUserDashboard);

// Rutas para servir los formularios de usuario
router.get('/user/mesaDeEntradas', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getMesaDeEntradas);
router.get('/user/gestion', authMiddleware, roleMiddleware(['USER', 'admin']), userController.getGestion);

// Ruta para servir el formulario de Dirección solo para admin lvl 9
router.get('/user/direccion', authMiddleware, adminLevelMiddleware('admin', 9), userController.getDireccion);

// Rutas para manejar las sumisiones de los formularios
router.post('/user/mesaDeEntradas', authMiddleware, roleMiddleware(['USER', 'admin']), userController.handleMesaDeEntradas);
router.post('/user/gestion', authMiddleware, roleMiddleware(['USER', 'admin']), userController.handleGestion);
router.post('/user/direccion', authMiddleware, adminLevelMiddleware('admin', 9), userController.handleDireccion);

// Rutas del dashboard de admin
router.get('/admin/dashboard', authMiddleware, roleMiddleware(['admin']), adminController.getAdminDashboard);

// Log de las funciones de controlador (opcional)
console.log('authController.login:', authController.login);
console.log('authController.logout:', authController.logout);
console.log('userController.getUserDashboard:', userController.getUserDashboard);
console.log('userController.getMesaDeEntradas:', userController.getMesaDeEntradas);
console.log('userController.getGestion:', userController.getGestion);
console.log('userController.getDireccion:', userController.getDireccion);
console.log('userController.handleMesaDeEntradas:', userController.handleMesaDeEntradas);
console.log('userController.handleGestion:', userController.handleGestion);
console.log('userController.handleDireccion:', userController.handleDireccion);
console.log('adminController.getAdminDashboard:', adminController.getAdminDashboard);

module.exports = router;



===== Archivo: ./routes/mesaDeEntradasRoutes.js =====
Carpeta: ./routes
Contenido:
// routes/mesaDeEntradasRoutes.js

const express = require('express');
const mesaDeEntradasController = require('../controllers/mesaDeEntradasController');
const authMiddleware = require('../middleware/auth');
const roleMiddleware = require('../middleware/role');
const userController = require('../controllers/userController');
const router = express.Router();

// Ruta para renderizar el formulario de Mesa de Entradas
router.get(
    '/mesaDeEntradas',
    authMiddleware,
    roleMiddleware(['USER', 'admin']),
    mesaDeEntradasController.getMesaDeEntradas
);

// Ruta para manejar la sumisión del formulario de Mesa de Entradas
router.get(
    '/mesaDeEntradas',
    authMiddleware,
    roleMiddleware(['USER', 'admin']),
    userController.getMesaDeEntradas
);

// Rutas API para obtener detalles de registros
router.get('/api/consultasEchas/:id', authMiddleware, mesaDeEntradasController.getConsultaEchasById);
router.get('/api/expedientes/:id', authMiddleware, mesaDeEntradasController.getExpedienteById);
router.get('/api/citaciones/:id', authMiddleware, mesaDeEntradasController.getCitacionById);
router.get('/api/pedidos/:id', authMiddleware, mesaDeEntradasController.getPedidoById);
router.get('/api/resoluciones/:id', authMiddleware, mesaDeEntradasController.getResolucionById);

module.exports = router;



===== Archivo: ./scripts/createTestuser.js =====
Carpeta: ./scripts
Contenido:
// scripts/createTestUser.js

const { createUser } = require('../models/userModel');

const crearUsuarioPrueba = async () => {
    const email = 'testuser@example.com';
    const password = 'password123'; // Contraseña en texto plano
    const role = 'USER'; // o 'admin'

    try {
        await createUser(email, password, role);
        console.log('Usuario de prueba creado exitosamente.');
    } catch (error) {
        console.error('Error al crear usuario de prueba:', error);
    }
};

crearUsuarioPrueba();



===== Archivo: ./server.js =====
Carpeta: .
Contenido:
// server.js

const express = require('express');
const helmet = require('helmet');
const path = require('path');
const session = require('express-session');
const rateLimiter = require('./middleware/rateLimiter');
const xssProtection = require('./middleware/xssProtection');
const authRoutes = require('./routes/authRoutes');
const mesaDeEntradasRoutes = require('./routes/mesaDeEntradasRoutes'); // Importar el nuevo archivo de rutas
const { sessionSecret } = require('./config/config');
const morgan = require('morgan');
const fs = require('fs');
const { createStream } = require('rotating-file-stream'); // Para rotación de logs
const cookieParser = require('cookie-parser');
const csrf = require('csurf'); // Importar csurf
require('dotenv').config();

const app = express();

// Middlewares de seguridad con Helmet
app.use(
    helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'"],
                styleSrc: ["'self'", 'https:'],
                imgSrc: ["'self'", 'data:'],
                connectSrc: ["'self'"],
                fontSrc: ["'self'", 'https:', 'data:'],
                objectSrc: ["'none'"],
                upgradeInsecureRequests: [],
            },
        },
    })
);

// Middleware para parsear cuerpos de solicitudes
app.use(express.urlencoded({ extended: false }));
app.use(express.json());

// Middleware para parsear cookies
app.use(cookieParser());

// Limitar solicitudes
app.use(rateLimiter);

// Protección contra ataques XSS
app.use(xssProtection);

// Logger para registrar solicitudes en logs
const logDirectory = path.join(__dirname, 'logs');

// Asegurarse de que el directorio de logs existe
fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);

const accessLogStream = createStream('access.log', {
    interval: '1d', // Rotar diariamente
    path: logDirectory
});

app.use(morgan('combined', { stream: accessLogStream }));

// Gestión de sesión
app.use(session({
    secret: sessionSecret,
    resave: false,
    saveUninitialized: true,
    cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict'
    }
}));

// Configurar csurf middleware después de cookieParser y session
app.use(csrf());

// Middleware para pasar el token CSRF a todas las vistas
app.use((req, res, next) => {
    res.locals.csrfToken = req.csrfToken();
    next();
});

// Motor de plantillas EJS
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware para servir archivos estáticos - DEBE ESTAR ANTES DE LAS RUTas
app.use(express.static(path.join(__dirname, 'public')));

// Rutas
app.use('/auth', authRoutes);
app.use('/auth/user', mesaDeEntradasRoutes); // Montar las rutas de Mesa de Entradas bajo /auth/user
// Ruta raíz redirige a login
app.get('/', (req, res) => {
    res.redirect('/auth/login');
});

// Manejo de errores global
app.use((err, req, res, next) => {
    if (err.code === 'EBADCSRFTOKEN') {
        // Manejar el error de CSRF
        res.status(403).json({ message: 'Formulario inválido' });
    } else {
        console.error(err.stack);
        res.status(500).json({ message: 'Ocurrió un error en el servidor' });
    }
});

// Iniciar servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Servidor corriendo en el puerto ${PORT}`);
});



===== Archivo: ./validations/loginValidation.js =====
Carpeta: ./validations
Contenido:
// validations/loginValidation.js

const Joi = require('joi');

const loginSchema = Joi.object({
    email: Joi.string().required().messages({
        'string.email': 'El correo debe ser válido.',
        'any.required': 'El correo es obligatorio.'
    }),
    password: Joi.string().min(1).required().messages({
        'string.min': 'La contraseña debe tener al menos 6 caracteres.',
        'any.required': 'La contraseña es obligatoria.'
    })
});

module.exports = loginSchema;



===== Archivo: ./views/adminDashboard.ejs =====
Carpeta: ./views
Contenido:
<!-- views/adminDashboard.ejs -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Dashboard de Administrador</title>
    <link rel="stylesheet" href="/css/dashboard.css">
</head>
<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside id="dashboardSidebar" class="dashboard-sidebar">
            <h2 class="sidebar-title">Menú de Admin</h2>
            <button id="btnUsuarios" class="sidebar-button">Gestión de Usuarios</button>
            <button id="btnConfiguracion" class="sidebar-button">Configuración</button>
            <!-- Agrega más botones según tus necesidades -->
        </aside>

        <!-- Overlay para dispositivos móviles -->
        <div id="sidebarOverlay" class="sidebar-overlay"></div>

        <!-- Main Content -->
        <main class="dashboard-main">
            <header class="dashboard-header">
                <h1 class="dashboard-title">Bienvenido, <%= admin.email %></h1>
                <p class="dashboard-role">Rol: <%= admin.role %></p>
                <!-- Botón para abrir el sidebar en dispositivos móviles -->
                <button id="openSidebarButton" class="open-sidebar-button">&#9776;</button>
            </header>

            <!-- Contenedor para los contenidos del dashboard -->
            <div id="adminContent" class="admin-content">
                <!-- Aquí puedes cargar diferentes secciones mediante JavaScript o enlaces -->
                <p>Contenido del Dashboard de Administrador.</p>
            </div>

            <!-- Botón para cerrar sesión -->
            <form action="/auth/logout" method="POST" class="logout-form">
                <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                <button type="submit" class="logout-button">Cerrar Sesión</button>
            </form>
        </main>
    </div>

    <script src="/js/dashboard.js"></script>
</body>
</html>



===== Archivo: ./views/dashboard.ejs =====
Carpeta: ./views
Contenido:
<!-- views/dashboard.ejs -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <link rel="stylesheet" href="/css/dashboard.css">
</head>
<body>
    <div class="dashboard-container">
        <!-- Sidebar -->
        <aside id="dashboardSidebar" class="dashboard-sidebar">
            <h2 class="sidebar-title">Menú</h2>
            <button id="btnMesaDeEntradas" class="sidebar-button">Mesa de Entradas</button>
            <button id="btnGestion" class="sidebar-button">Gestión</button>
            <% if (user.role === 'admin' && user.lvl === 9) { %>
                <button id="btnDireccion" class="sidebar-button">Dirección</button>
            <% } %>
        </aside>

        <!-- Overlay para dispositivos móviles -->
        <div id="sidebarOverlay" class="sidebar-overlay"></div>

        <!-- Main Content -->
        <main class="dashboard-main">
            <header class="dashboard-header">
                <h1 class="dashboard-title">Bienvenido, <%= user.email %></h1>
                <p class="dashboard-role">Tu rol es: <%= user.role %></p>
                <!-- Botón para abrir el sidebar en dispositivos móviles -->
                <button id="openSidebarButton" class="open-sidebar-button">&#9776;</button>
            </header>

            <!-- Contenedor para los formularios -->
            <div id="formContainer" class="form-container">
                <!-- Los formularios se cargarán aquí -->
            </div>

            <!-- Botón para cerrar sesión -->
            <form action="/auth/logout" method="POST" class="logout-form">
                <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                <button type="submit" class="logout-button">Cerrar Sesión</button>
            </form>
        </main>
    </div>

    <script src="/js/dashboard.js"></script>
</body>
</html>



===== Archivo: ./views/forms/direccion.ejs =====
Carpeta: ./views/forms
Contenido:
<!-- views/forms/direccion.ejs -->
<form id="direccionForm" class="direccion-form" action="/auth/user/direccion" method="POST">
    <input type="hidden" name="_csrf" value="<%= csrfToken %>">
    <div class="form-group">
        <label for="direccionField" class="form-label">Campo de Dirección:</label>
        <input type="text" id="direccionField" name="field3" class="form-input" required>
    </div>
    <button type="submit" class="form-submit-button">Enviar Dirección</button>
</form>



===== Archivo: ./views/forms/gestion.ejs =====
Carpeta: ./views/forms
Contenido:
<!-- views/forms/gestion.ejs -->
<form id="gestionForm" class="gestion-form" action="/auth/user/gestion" method="POST">
    <input type="hidden" name="_csrf" value="<%= csrfToken %>">
    <div class="form-group">
        <label for="gestionField" class="form-label">Campo de Gestión:</label>
        <input type="text" id="gestionField" name="field2" class="form-input" required>
    </div>
    <button type="submit" class="form-submit-button">Enviar Gestión</button>
</form>



===== Archivo: ./views/forms/mesaDeEntradas.ejs =====
Carpeta: ./views/forms
Contenido:
<div>
    <!-- Tabla de Consultas Echas -->
    <h2>Consultas Echas</h2>
    <table id="consultasEchasTable" class="display">
        <thead>
            <tr>
                <th>ID</th>
                <th>Nombre del Usuario</th>
                <th>Motivo de la Consulta</th>
                <th>Explicación Dada</th>
                <th>DNI</th>
                <th>Fecha y Hora de Alta</th>
                <th>Acciones</th>
            </tr>
        </thead>
        <tbody>
            <% if (consultasEchas && consultasEchas.length > 0) { %>
                <% consultasEchas.forEach(consulta => { %>
                    <tr>
                        <td><%= consulta.id %></td>
                        <td><%= consulta.nameuser %></td>
                        <td><%= consulta.motivodelacon %></td>
                        <td><%= consulta.explicaciondada %></td>
                        <td><%= consulta.dni %></td>
                        <td><%= consulta.fechayhoradealta %></td>
                        <td><button class="view-details" data-id="<%= consulta.id %>">Ver Detalles</button></td>
                    </tr>
                <% }) %>
            <% } else { %>
                <tr>
                    <td colspan="7">No hay consultas registradas en este momento.</td>
                </tr>
            <% } %>
        </tbody>
    </table>

    <!-- Modal para Mostrar Detalles -->
    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div id="modalBody">
                <!-- Los detalles se cargarán aquí -->
            </div>
        </div>
    </div>
</div>



===== Archivo: ./views/login.ejs =====
Carpeta: ./views
Contenido:
<!-- views/login.ejs -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Iniciar Sesión</title>
    <link rel="stylesheet" href="/css/login.css">
</head>
<body>
    <div class="login-container">
        <form id="loginForm" class="login-form" action="/auth/login" method="POST">
            <h2 class="login-title">Iniciar Sesión</h2>
            <input type="hidden" name="_csrf" value="<%= csrfToken %>">
            <div class="login-field">
                <label for="email" class="login-label">Correo Electrónico:</label>
                <input type="text" id="email" name="email" class="login-input" required>
            </div>
            <div class="login-field">
                <label for="password" class="login-label">Contraseña:</label>
                <input type="password" id="password" name="password" class="login-input" required>
            </div>
            <button type="submit" class="login-button">Ingresar</button>
        </form>
    </div>

    <script src="/js/login.js"></script>
</body>
</html>



